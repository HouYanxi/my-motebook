# HTML

## html语义化的理解

写的HTML代码的标签让人一见到就知道是什么意思，一方面有利于开发者阅读开发，另一方面有利于浏览器和爬虫更好的解析网页内容。

* 增强可读性，即使没有css的时候，也能清晰的看出网页结构，比如p、div、ul...

* 便于团队开发和维护，语义化的html让开发者更容易看明白，提高效率
* 便于搜索引擎爬虫更好的获取网页内容，比如h1、h2、p这些权重不一样
* 为加强语义化，h5还新出了其它标签<header><nav><main><sectoin><aside><article><footer>

## 块级标签和内联标签

1. 块级标签：<div>、<hn>、<p>、<ul>、<li>、<table>...
2. 内联标签：<a>、<span>、<img>、<strong>、<input>、<select>...
3. 区别：

   * 块级标签独占一行，元素宽度默认占满父级元素

   * 行内标签有多宽占多宽，宽高设置无效

   * 块级标签可以设置margin和padding，行内标签设置水平方向的有效果，竖直方向无效果。
4. 两个标签的转换：
   * dispaly:block、display:inline、display:inline-block(既不独占一行，又有宽高)

## head里面的meta属性



## 浏览器内核

1、浏览器主要分为两个部分：渲染引擎和JS引擎

* 渲染引擎：获取页面内容和排版渲染页面

* JS引擎：解析和执行JS代码，实现页面动态效果和交互内容

2、常用浏览器的内核

| 私有前缀 |            浏览器            |  内核   |
| :------: | :--------------------------: | :-----: |
|   -o-    |        opera（欧鹏）         | presto  |
|   -ms-   |              IE              | Trident |
|  -moz-   |       Firefox（火狐）        |  Gecko  |
| -webkit- | chrome（谷歌）、safari(苹果) | webkit  |

可以在属性前面加私有前缀，解决部分css兼容问题：`-o-color:red`；

## H5新特性

* 语义化标签
* websocket（及时通讯，双全工，QQ微信）
* 本地存储（localstorage永久有效、sesstionstorage一次会话有效）
* 多媒体（<video>视频、<audio>音频，添加src文件路径和控件controls）
* canvas画布和SVG画布（网页游戏、企业图标）
* 新增表单控件和表单属性（eg:   `type="emial"`验证email格式  ，`autocomplete="on"`再次回到表单内容不会清空）
* 参考文档：[H5主要新特性](https://blog.csdn.net/lemon_yu/article/details/98451447?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162562838116780261948219%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162562838116780261948219&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-98451447.first_rank_v2_pc_rank_v29_1&utm_term=H5%E6%96%B0%E7%89%B9%E6%80%A7&spm=1018.2226.3001.4187) 、 [H5的新特性](https://blog.csdn.net/weixin_42441117/article/details/80705203?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162562838116780261948219%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162562838116780261948219&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-80705203.first_rank_v2_pc_rank_v29_1&utm_term=H5%E6%96%B0%E7%89%B9%E6%80%A7&spm=1018.2226.3001.4187)

# CSS

## href与src的区别

* href是对文件的引用，指向外部文件所在的位置。常用于`a`、`link`

```
<a href="http://www.baidu.com">百度一下</a>
<link type="text/css" rel='stylesheet' href="my.css">
```

* scr是对文件的引入，外部的文件直接成为文件的一部分内容。常用于`img`、`iframe`、`script`

```
<img scr="my.jpg" alt="出错了"/>
<iframe src='my.html'></iframe>
<script scr='my.js'></script>
```

**浏览器的解析**

1、当遇到href时，解析href资源的同时，会同时解析当前文件（引用CSS时用link而不用@import）

2、当遇到src时，直到src里面的内容解析完毕才会接着往下解析文件（引入js放在底部的原因）

## link和@import引用css的区别

两者都是外部引用的方式，区别：

* 性质不一样，link是html标签除`加载css以外还可定义RSS`，@import属于css的语法，`只能加载css`
* 渲染顺序，link是载入网页时就加载css，而@import是`将网页完全载入以后再加载css`
* 兼容问题，link是html标签不存在，@import需要兼容,css2.1出的，低版本浏览器无法兼容
* link支持使`用JS控制DOM改变样式`，@import不支持。

## 层级（继承&优先级）

### 继承

在css中外层元素的样式会被内层元素拥有

* 可以继承的属性：文本列表相关，`font-size、font-family、color`...

* 不可继承的属性：`border、padding、margin、height`...

### 选择符

* 通用选择器 *{}

* 标签选择器 tag{} #id{} .class{}

* 层次选择器  子代E1>E2{}，后代E1 E2{}

* 伪类选择器   :hover{}

### 优先级

!important>行内样式 `1000`>id `100`>class `10`（属性选择器E[attr]、伪类选择器:hover{}）>标签  `1`（伪元素:after{}）>*>继承>默认

* 权重计算方式：计算权重值之和，谁大谁优先，相同时后者覆盖前者
* ！important IE6不支持


## css盒子模型

1、盒子模型作用：主要用于css布局

2、组成：内容+内边距+边框+外边距

3、分类：标准盒模型+怪异盒模型

* 标准盒模型就是浏览器按照w3c标准解析执行代码
* 怪异盒模型就是浏览器按照自己的方式解析执行代码，不同的浏览器执行方式不一样
* 网页使用的哪种模型，要看文档声明DTD时定义的哪种标准，可以使用`window.top.document.compatMode`查看。

### 标准盒模型

```
<div style="border:5px solid blue;padding:10px;margin:10px;width=500px">2324354365765ffhkluilijshjsdkpoi</div>
```

> 设置的宽度width就是内容的宽度，盒子的宽度=内外边距+边框+内容（content-box）
>
> 当padding,margin这些变化，整个盒子会被撑大
>
> ![image-20210629214219751](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210629214235.png)
>
> ![image-20210629214401386](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210629214401.png)

```
  <div style='width:800px;border: 3px solid black;'>
      <div style="padding:10px; border:5px solid blue; margin: 10px;"> 之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，
  文章言简意赅的介绍的浏览器的工作过程，web前端 之前看过一篇文章，
    叫做《浏览器工作原理：新式网络浏览器幕后揭秘》， 文章言简意赅的介绍的浏览器的工作过程，web前端 
      </div>
  </div>
```

> 还有一种情况是：盒子模型是块级元素，未自定义宽度时，盒子宽度随父元素
>
> 当padding,margin变化，会挤压内容的宽度
>
> ![image-20210629215559471](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210629215559.png)
>
> ![image-20210629215634136](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210629215634.png)

### 怪异盒子模型

```
<div style='width:800px;border: 3px solid black;'>
    <div style="padding:10px; border:5px solid blue; margin: 10px;width:500px；box-sizing:border-box"> 之前看过一篇文章，叫做《浏览器工作原理：新式网络浏览器幕后揭秘》，
文章言简意赅的介绍的浏览器的工作过程，web前端 之前看过一篇文章，
  叫做《浏览器工作原理：新式网络浏览器幕后揭秘》， 文章言简意赅的介绍的浏览器的工作过程，web前端 
    </div>
</div>
```

> 怪异盒子模型添加一个box-sizing:border-box就可以实现(父元素不要)
>
> 盒子设置的width宽度=内容+内边距+边框(不包含margin)，当内边距和边框发生变化挤压的是内容
>
> 适用于手机端布局,bootstrap就用的这个

![image-20210629220058164](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210629220058.png)

![image-20210629223102451](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210629223104.png)

## 水平/垂直居中

### 水平居中

1、使用text-align:center(适用于被包含的元素是inline元素，在父元素上设置)

```
.container{
	text-align:center;
}
```

2、被包含的元素是块级元素，固定宽度+margin:auto

```
.container{
	text-align:center;
}
.items{
	width:1000px;
	margin:auto;
}
```

3、绝对定位+负外边距（已知子元素宽度前提）

```
.container{
	position:relative;
	height:500px;//避免父元素塌陷
}
.item{
	width:300px;
	height:100px;
	position:absolute;
    left:50%;
    margin-left:-150px;
}
```

### 垂直居中

1、单行文字垂直居中（设置被包含的是inline元素）

```
.container{
	height:60px;
	line-height:60px
}
```

2、绝对定位+负外边距（已知子元素宽高 ）

```
.container{
	position:relative;
	height:500px;//避免父元素塌陷
}
.item{
	width:300px;
	height:100px;
	position:absolute;
    left:50%;
    top:50%;
    margin-left:-150px;
    margin-top:-50px;
}
```

3、绝对定位+css3变形transform

```
.container{
	position:relative;
	height:500px;//避免父元素塌陷
}
.item{
	width:300px;
	height:100px;
	background:blue;
	position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);//x轴和y轴分别平移这么多距离
}
```

4、绝对定位+margin:auto

```
.container{
	position:relative;
	height:500px;//避免父元素塌陷
}
.item{
	width:300px;
	height:100px;
	position:absolute;
    top:0;
    bottom:0;
    left:0;
    right:0;
    margin:auto;
}
```



## 定位（position）

1、定义：position是css中用于布局的属性

2、写法：

​		position:	static	|	relative	|	absolute	|	fixed;

​		位置控制取值   left	|	right	|	top	|	bottom

3、分类

* **固定定位 fixed** ：基于浏览器窗口或body进行定位，会脱离文档流，【情景：广告弹窗】

* **相对定位 relative:** 基于元素自身进行定位，不会脱离文档流

* **绝对定位 absolute:** 基于被设置了非static定位的上级元素定位，会脱离文档流

  ​								   如果父级或上级都未设置非static定位，基于浏览器窗口定位

  ​                                   通常借助在父级上设置relative来实现绝对定位

  ​								   【场景：用于在一个盒子上面定位显示另一个盒子】

## 圣杯布局

实现效果：三列布局，中间自适应，两边固定

![image-20210701110028992](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210701110353.png)

> 浮动、负外边距、相对定位

实现步骤：

1. 一个大盒子包裹三个小盒子，中间盒子放最上面（html）

2. 中间盒子宽度100%，其它固定宽度，三个小盒子浮动（父级清浮动）

3. 左边设置margin-left:-100%,右边设置margin-left:-自身宽度（将左右盒子与中间放置一行，中间盒子的内容被左边遮挡）

4. 父级设置左右内边距，大小为左右盒子的宽度

5. 左右盒子设置相对定位，left:-自身宽度，right:-自身宽度

6. 注意：可以给body设置一个最小宽度，网页宽度过小会挤走两个小盒子。

   ```
   *{
               margin: 0;
               padding: 0;
           }
           /* 宽度过小，两边的盒子会被挤走*/
           body{
               min-width: 800px;
           }
           .wrap{
               border: 1px solid black;
               overflow: hidden;
               
           }
           .middle{
               background: red;
               width: 100%;
               height: 200px;
               float: left;
           }
           .left{
               background-color: green;
               width: 200px;
               height: 200px;
               float: left;
               margin-left: -100%;
           }
           .right{
               background-color: blue;
               width: 200px;
               height: 200px;
               float: left;
               margin-left: -200px;
           }
           .child{
               margin: 0 200px;
           }
       </style>
   </head>  
   <div class="wrap">
   	<div class="middle">
   		<div class="child">中间</div>
   	</div>
   	<div class="left">左边</div>
   	<div class="right">右边</div>
   </div>
   ```

### 双飞翼的布局

同样的效果：

第4、5步替换成：为中间盒子加一个子元素div，为他设置左右外边距，大小为左右盒子的宽度。

## flex布局

常用的网页布局：display、float、position

flex弹性布局：更快、更好的实现响应式布局，注意，设为 Flex 布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。

[flex弹性布局语法](https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)、[flex弹性布局案例](https://www.ruanyifeng.com/blog/2015/07/flex-examples.html)

**flex实现圣杯布局**

![image-20210701132121032](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210701132122.png)

```
<style>
        #main{
            display: flex;
            /* 保证父元素有宽高 */
            height: 100vh;
            flex-direction: column;
        }
        header,footer{
            background: gray;
            flex: 0 0 60px;
        }
        #main>.content{
            display: flex;
            flex:1;
        }
        .left{
            background: yellow;
            flex: 0 0 20%;
            order: -1;
        }
        .center{
            background: blue;
            flex: 1;
        }
        .right{
            background: green;
            flex: 0 0 20%;
        }
        @media(max-width: 768px){
            #main>.content{
                flex-direction: column;
            }
            #main>.content>div{
                flex: 1;
            }
            .left{
                background: red;
            }
        }
     
    </style>
</head>
<body>
    <div id="main">
        <header>#header</header>
        <div class="content">
            <div class="left">#left</div>
            <div class="center">#center</div>
            <div class="right">#right</div>
        </div>
        <footer>#footer</footer>
    </div>
</body>
```

**实现重点：**

1. 保证父元素有宽高，（基于整个浏览器，推荐用vh单位）
2. 父元素上开启`display:flex`属性
3. 接下来就可以设置父元素属性（子元素的整体排列方式）和项目属性（单个子元素的排列，占比）了
4. justify-content主轴对齐方式      align-items侧轴对齐方式

## 回流&重绘

* **重绘**：页面元素不脱离文档流，进行简单的样式变化的时候，改变元素的`颜色`、`背景`，浏览器会重新绘制样式

* **回流：**改变处于文档流中DOM的`尺寸大小`、`位置`、`属性`的时候，浏览器会重新渲染部分或全部文档

* **回流一定会引起重绘**，重绘不一定引起回流，回流消耗更大。

* 参考文档：[你真的了解回流和重绘吗](https://juejin.cn/post/6844903734951018504)

  > 案例，请对以下代码进行优化

```
 <style>
        .box{
            width: 200px;
            height: 200px;
            background: red;
        }
        .active{
            padding: 20px;
            margin: 20px;
            background-color: yellow;
        }
</style>
<div class="box">
	dqwhdjghfwehjf
</div>
<script>
	var data=['string1','string2','string3'];
    for(var i=0;i<data.length;i++){
    	var dom=document.getElementsByClassName('box')[0];
    	dom.innerHTML+=`<li>我是字符串${data[i]}</li>`;//渲染三次
    }
</script>
```

> 一、字符串累加的方式，一次性渲染

```
var data=['string1','string2','string3'];
var str='';
for(var i=0;i<data.length;i++){
     str+=`<li>我是字符串${data[i]}</li>`;
     }
var dom=document.getElementsByClassName('box')[0];
dom.innerHTML+=str;
```

> 二、使用documentFragment,创建临时容器，一次性渲染

```
var data=['string1','string2','string3'];
var frag=document.createDocumentFragment()
for(var i=0;i<data.length;i++){
	 var liBox=document.createElement('li');
	 liBox.innerHTML=`我是字符串${data[i]}`; 
	 frag.appendChild(liBox);
     }
var dom=document.getElementsByClassName('box')[0];
dom.appendChild(frag);
```

## css3动画

* 通过对关键帧的设置实现动态效果

* 实现步骤：

  1. 定义关键帧

     ```
      @keyframes myAnimation {
                 0%{background: red;left: 0;top: 0;}
                 25%{background: yellow;left: 200px;top: 0;}
                 50%{background: blue;left: 200px;top: 200px;}
                 75%{background: green;left: 0;top: 200px;}
                 100%{background:pink;left: 0;top: 0;}
             }
     ```

  2. 针对一个css选择器来调用动画

     ```
     div{
                 width: 60px;
                 height: 60px;
                 background:#dddddd;
                 position: absolute;
     
                 animation-name: myAnimation;
                 animation-duration: 2s;
             }
     <body>
         <div>123</div>
     </body>
     ```

* 实现动画还有css3`过渡transition`、`css3变形transform`属性
  1. transition过渡是从一个状态过渡到另一个状态，实际上是监测css属性的变化，比如检测到高度100px变为200px的过渡动画，通常与：hover伪类搭配
  2. tranform属性是对函数的调用，实现平移、缩放、旋转等效果，通常与：hover伪类、过渡搭配
  3. 参考文档：[探究CSS3中的transition和transform属性方法使用](https://blog.csdn.net/JackieDYH/article/details/106556307?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162514715216780265425663%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162514715216780265425663&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-9-106556307.first_rank_v2_pc_rank_v29_1&utm_term=transition%E7%9A%84%E4%BD%BF%E7%94%A8&spm=1018.2226.3001.4187)

## BFC（Block Formatting Context）

* 块级格式上下文的表现：一个块级格式上下文就是一个独立的作用域，盒子会从包含块的顶端开始垂直地一个接一个排列，垂直间隙是由margin值决定的，两个相邻的块级盒子垂直外边距会发生叠加。

  -每个盒子的左右边缘会触碰到容器的边缘，即使浮动也是如此，除非创建一个新的块级格式上下文。

* 哪些内容会出现块级格式化上下文：浮动元素、绝对定位元素、非块级盒子的块级容器（inline-blocks,table-cells,table-captions）,overflow取值“aoto”,“hidden”的块级盒子。

## 浮动和清除浮动

 ### 浮动

1、定义：浮动是一种css定位属性，主要实现页面的一行多列（最初是为了解决文字环绕图片的问题）

2、浮动会产生哪些影响：

* 破坏性，设置浮动元素的父元素会发生高度塌陷

* 包裹性，设置浮动的块元素宽度调整为包裹内容的宽度，而不是撑满整个父容器了

* 清空格

* 脱离文档流，产生自己的块级格式上下文

### 清除浮动的常见方法

1、浮动元素的最后一个兄弟元素后面添加一个空元素，设置样式`clear:both；`

2、为浮动元素的父亲设置固定高度，或设置`overflow:hidden/auto`属性;

3、给浮动元素的父元素添加一个.clearfix的类名，并添加伪元素

```
.clearfix:after{
	content:'';
	display:block;
	height:0;
	clear:both
}
.clearfix{
	zoom:1//兼容IE6、IE7,因为他两不支持after伪类
}
```

## 预处理器less&sass

什么是预处理器：

CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题

例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性

### less

less是css预处理编程语言，可以生成.css目标文件，有变量、混合、嵌套、继承、颜色五大基本特性。

> lesss语言好处：
>
> 1、结构清晰，便于扩展
>
> 3、可以方便的屏蔽浏览器私有语法差异
>
> 3、可以轻松实现多重继承
>
> 4、完全兼容CSS代码，可以方便的应用到老项目中。

1. 全局安装（C:/user/Ademin/AppData?Roaming/npm/lessc.cmd）,安装在全局下所有项目都可以直接使用，而不用再次安装。

   > npm i less -g

2. 新建02.less文件

   ![image-20210709111759064](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210709111802.png)

   3. 编译(项目根目录，node命令行中)

      > lessc	02.less	filename.css 

   4. 在html中引入即可

      <link rel="stylesheet" href="filename.css"/>

### 语法 (变量)

1. 注释

   less支持支持单行注释`//`，以及多行注释`/*   */`

   css只支持单行注释

2. 变量

   ![image-20210710141159203](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210710141159.png)



# JS

## this用法及原理

> this的作用就是在函数体内，指代当前运行环境

### this的几种场景

* 全局的this==window

* 函数中的this（谁调用函数，函数中的this就指向谁，如果没有调用者默认指向window，`匿名函数`、`定时器`）

```
//声明位置
var fn=function(){
	console.log(this.x)
}    
var x="2"
var obj={
    x:"1",
    fn:fn
}
//调用位置
obj.fn();//1
//调用位置
fn();//2
```

```
 var that=this;
 (function(){
 	console.log(this===that)//true
 })()
 setTimeout(() => {
 	console.log(this===that)//true
 }, 0);
```

* 对象方法中的this指向对象本身

* 事件处理函数中的this指向事件源本身

* 函数被实例化(new 构造函数名())的情况下,this指向全新的对象

  ```
  function test2(){
  	console.log(this)//m
  }
  var m = new test2();
  ```

  

* call,apply,bind修改this指向

### ES5和ES6中this区别

![image-20210709214138424](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210709214139.png)

参考文章：[JS this详解](https://blog.csdn.net/qq_39816673/article/details/88907952?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162583540816780262535662%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162583540816780262535662&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-18-88907952.first_rank_v2_pc_rank_v29_1&utm_term=JS%E7%9A%84this%E5%8F%8A%E5%8E%9F%E7%90%86&spm=1018.2226.3001.4187)

## 原型、原型链

![image-20210709222134086](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210709222139.png)

![image-20210709222309390](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210709222309.png)

![image-20210709222715847](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210709222716.png)

## 闭包

![image-20210711165239152](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210711165244.png)

## 面向对象

1. ECMAScript 有两种开发模式：1.面向过程化编程，2.面向对象(OOP）

* 面向过程：事无巨细亲历亲为
* 面向对象：找一个对象，指挥得结果
* 面向对象是对面向过程的封装

2. 面向对象是一种思想，基本思想是使用对象、类、继承、封装等基本概念来进行程序设计

3. 在JS中万物皆对象，既有原生对象，也有自定义对象，**自定义的对象数据类型就是面向对象中的类（ Class ）的概念。**(类似prototype作用，是语法糖)。

   ![](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210711201240.png)

    Class 是一种抽象概念，比如我们定义的 Class——Student ，是指学生这个概念， 而实例（Instance）则是一个个具体的 Student 比如， 张三 和 李四 是两个具体的 Student 。

4. 面向对象三大特性

   * 封装
   * 继承
   * 多态
### 封装

1. 首先是对象的创建，我们可以**new Object()**和**字面量方式**来创建

   ```
   var person = new Object()
   person.name = '张三'
   person.age = 18
   
   person.sayName = function () {
     console.log(this.name)
   }
   ```

   ```
   var person = {
     name: '张三',
     age: 18,
     sayName: function () {
       console.log(this.name)
     }
   }
   ```

2. 但如果要创建多个对象，代码就会冗长，因此引入**工厂函数**

   ```
   function createPerson (name, age) {
     return {
       name: name,
       age: age,
       sayName: function () {
         console.log(this.name)
       }
     }
   }
   
   var p1 = createPerson('张三', 18)
   var p2 = createPerson('李四', 18)
   ```

3. 工厂函数虽然解决了代码冗长，但是我们并不能识别一个对象的类型，因此引入**构造函数**

   ```
   function Person (name, age) {
     this.name = name
     this.age = age
     this.sayName = function () {
       console.log(this.name)
     }
   }
   
   var p1 = new Person('张三', 18)
   p1.sayName() // => 张三
   
   var p2 = new Person('李四', 23)
   p2.sayName() // => 李四
   
   console.log(p1 instanceof Person)//true
   ```

4. 构造函数的问题在于每个实例化对象都会创建相同的方法，占用内存，因此引入了**原型**。

   ```
   function Person3(options) {
       this.name = options.name;
       this.age = options.age;
   }
   Person3.prototype.say = function () {
       console.log("原型  " + this.name);
   }
   
   var person3 = new Person3({ name: 'C', age: 21 });
   console.log(person3);/* Person3 {name: "C", age: 21} */
   person3.say();/* 原型  C */
   console.log(person3.__proto__);/* say: ƒ ()   constructor: ƒ Person3(options) */
   ```

### 继承

继承是让子类实例化出来的对象，拥有父类所有的属性和方法

1. **构造函数继承**

   在子类构造函数中绑定父类构造函数指向子类并执行
   优点：只能继承父类实例属性和方法，以及向父类传参
   缺点：不能继承父类原型上属性和方法

   ```
   /* 构造函数继承 */
   function Parent() {
       this.name =name || "zhangsan";
       this.age = age || 18;
   }
   Parent.prototype.say = function () {
       console.log(this.name);
   }
   function Son(name,age) {
       Parent.call(this,name,age);
       this.sex = "male";
   }
   
   let son = new Son();
   console.log(son);//Son { name: 'zhangsan', age: 18, sex: 'male' }
   // son.say();//报错
   consoloe.log(son instanceof Parent)//false son只是自己Son的实例
   ```

2. **原型继承**

   将子类原型绑定到一个父类的实例中实现继承
   优点：父类原型的方法属性能让子类实例对象继承
   缺点：子类实例修改父类引用属性会引起所有子类实例的属性改变，子类原型上多了许多不需要的父类属性，造成内存浪费

   ```
   /* 原型链继承 */
   function Parent() {
       this.name = "zhangsan";
       this.age = 18;
       this.hobbies = ['music', 'painting'];
   }
   Parent.prototype.say = function () {
       console.log(this.name);
   }
   function Son() {
       this.sex = "male";
   }
   
   Son.prototype = new Parent();
   
   let son = new Son();
   let son2 = new Son();
   console.log(son);//Son {sex:'male' }
   son.say();//zhangsan
   console.log(son.hobbies);//[ 'music', 'painting' ]
   //son改变引起son2改变
   son.hobbies.push('reading');
   console.log(son.hobbies);//[ 'music', 'painting', 'reading' ]
   console.log(son2.hobbies);//[ 'music', 'painting', 'reading' ]
   consoloe.log(son instanceof Parent)//true
   ```

3. **组合继承**

   在子类构造函数中绑定父类构造函数指向子类并执行，传入父类参数。
   利用原型继承方法：将Father的实例对象作为Son的原型，并且把Son原型的constructor强制改为Son，Son可以通过__proto__访问父类的方法。

   ```
   function Father(name, age) {
       this.name = name;
       this.age = age;
   }
   Father.prototype.money = function () {
       console.log(100000);
   }
   function Son(name, age) {
       // 借用父类构造函数，改变this指向实现继承属性
       Father.call(this, name, age);
   }
   /* 将Father的一个实例作为Son的原型 */
   Son.prototype = new Father();//或者Object.create(Father.prototype);
   
   /* Father实例的constructor是Father,需要强制改为Son */
   Son.prototype.constructor = Son;
   
   //Son自己的方法
   Son.prototype.exam = function () {
       console.log("100分");
   }
   console.log(new Son('Mike', 11));/* Son {name: "Mike", age: 11} */
   
   ```

   > 组合继承会调用两次父类构造函数，第一次调用时会将Paren中的name和age属性写入到Son的原型中，第二次调用的时候是在创建一个Son实例的时候，此时会将Parent中的name和age属性写入到Son实例中。
   > 相同的属性既被写入了原型中，又被写入了实例中，这是没有必要的=>寄生组合继承

4. **寄生组合继承（推荐使用）**

   将父类原型赋给了子类，将构造函数设置为子类，解决了无用属性和方便找到子类构造函数

   Object.create(prop[,propertiesObject]);使用指定的原型对象及其属性去创建一个新对象

   该方法常用于继承，var a=Object.create(Null);也可以创建一个空对象

   ```
   function Parent(name){
   	this.na=name;
   }
   Parent.prototype.getName=function(){
   console.log(this.na);
   }
   //1.子类继承父类实例属性方法
   function Child(value){
   	Parent.call(this,value);
   }
   //2.继承父类原型属性方法（给子类原型赋值的过程，不调用父类构造函数，直接继承父类原型）
   // Child.prototype=Object.create(Parent.prototype,{
   //     constructor:{
   //         value:Child,
   //         enumerable:false,
   //         writable:true,
   //         configurable:true,
   //     }
   // });
   
   //2.2简易版
   Child.prototype=Object.create(Parent.prototype);
   Child.prototype.constructor=Child;
   
   var child=new Child('李四');
   console.log(child);
   child.getName();
   console.log(child instanceof Parent);
   ```

5. **ES6的extends关键字继承**

   与其它语言类似，直接在定义时加关键字，注意的是构造函数里面需要用super传参，并且super必须在最前面

   JS中不存在类，class只是语法糖，本质上还是函数。

   ```
   class Father {
       constructor(name, age) {
           this.name = name;
           this.age = age;
       }
       showInfo() { console.log(this.name, this.age); }
   }
   class Son extends Father {
       constructor(name, age) {
           super(name, age);//传入父类的参数
           this.name = name;
           this.age = age;
       }
   }
   var son = new Son('zhangsan', 22);
   console.log(son);/* Son {name: "zhangsan", age: 22} */
   son.showInfo();/* zhangsan 22 */
   ```
### 多态

多态的概念是对同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。

```
function Dog() { };
function Cat() { };
Dog.prototype.sound = function () { console.log("汪！") }
Cat.prototype.sound = function () { console.log('喵！') };

function makeSound(animal) {
    animal.sound();
}
makeSound(new Dog());//汪！
makeSound(new Cat());//喵！
```

### 重载

一个方法内根据传参情况不同做出不同表现，在JavaScript中，同一个作用域，出现两个名字一样的函数，后面的会覆盖前面的，所以 JavaScript 没有真正意义的重载。

```
function count(){
    if(arguments.length%2==1){
        console.log( "奇数个参数");
    }else{
        console.log("偶数个参数");
    }
}

count('a','b','c',[2,3,1,5,1,0]);
count({a:1,b:2,c:3});
```

![image-20210711213932280](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210711213939.png)

### 重写

继承了父类，但是自己原型上定义了同名方法，在调用时执行自己原型上的方法。

```
function Father(name, age) {
    this.name = name;
    this.age = age;
}
Father.prototype.money = function () {
    console.log(100000);
}
function Son(name, age) {
    // 借用父类构造函数，改变this指向实现继承属性
    Father.call(this, name, age);
}
/* 将Father的一个实例作为Son的原型 */
Son.prototype = new Father();

/* Father实例的constructor是Father,需要强制改为Son */
Son.prototype.constructor = Son;

/* Son重写方法 */
Son.prototype.money = function () {
    console.log(100);
}
var son = new Son('Mike', 11);
son.money();//100
```


## 同步异步

![image-20210711220517175](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210711220517.png)

## 回调函数

> 当一个函数作为参数传给另一个函数使用时，作为参数传递的函数叫做回调函数

1. 作为参数传递的两种形式

   * 以函数名作为参数的方式

   * 以匿名函数作为参数的方式

     ```
     function say (value) {
         alert(value);
     }
     function execute (someFunction, value) {
         someFunction(value);
     }
     execute(say, 'hi js.');
     ```

     ```
     function execute (someFunction, value) {
         someFunction(value);
     }
     execute(function(value){alert(value);}, 'hi js.');
     ```

2. 回调函数的参数传入另一个函数的两种方式

   * 传回调函数时，把参数一起传递了（如上）

   * 在调用回调函数的内部进行创建

     ```
     function say(value){
     	console.log(value.name);
     }
     function execute(fun){
     	var obj={            //在函数内部自定义一些回调函数所需的对象及属性
     		name:'zhangsan';
     	}
     	fun(obj);
     }
     execute(say);
     ```

## Promise对象

1. Promsise是一个ES6的新增类，在Promise对象里面可以处理异步代码

2. 它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。

3. 利用promise可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数（回调地狱），.then()支持链式调用。

   ![image-20210712182352337](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210712182355.png)

   ```
   //创建一个Promise对象
   var promise=new Promise(function(resolve,reject){
   	//进行一些异步或耗时操作
   	if(处理结果成功){
   		resolve('Yes');//类似return
   	}else{
   		reject('No');
   	}
   })
   //绑定处理程序
   promise.then(function(res){
   	console.log(res)//Yes
   },function(err){
   	console.log(err)//No
   });
   ```

   

## async、await

相同点：都是函数修饰词,放在一个函数前面，（都是修饰的Promise对象）

### async

async:异步,函数修饰词，返回一个Promise对象，

**异步函数具体执行在.then()方法处**，后面的代码不必再等异步函数执行完，就可以执行

```
console.log(111);
async function show(){
    return 222;
}

console.log(show());

show().then(function(data){
	console.log(data);
})
console.log(333);
```

![image-20210711215214803](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210711215215.png)

### await

awiat,同步，只能在异步函数中使用，等待一个函数返回一个结果（必须是一个Promise对象）后，再继续执行，实现同步作用

```
function timer(){
	return new Promise(function(resolved,rejected){
    setTimeout(function(){
            console.log(111);
            //变成同步后，不添加resolved（）函数就不会往后执行
            resolved();
        },2000)
    })
}

async function show(){
	console.log(timer());
    await timer();
    console.log(222);
}

show();//2秒后先打印111，再打印222
```

![image-20210711222833082](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210711222833.png)

## 模块化、CommonJS、AMD

1. 定义：将一个复杂的程序按照一定的规范或功能封装成几个模块（文件），模块内部的数据是私有的，只是向外部提供一些通信的接口。

2. 模块化的好处：

   * 减少命名冲突，防止全局污染
   * 提高代码复用性
   * 提高代码的可维护性
   * 更好的分离，按需加载

3. 模块化分类

   

   ![image-20210712220753374](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210712220810.png)

### ES Moudle

   ![image-20210712221044010](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210712221044.png)

 ### Bable-Browserify的使用

1. 新建一个项目，新建包描述文件package.json

>>npm init
>>{
>>"name":"es6-babel-browserify",
>>"version":"1.0.0"
>>}

2. *安装babel-cli,提供babel命令
   //cli:command line interface
   *安装babel-preset-es2015模块
   *browserify模块

>>npm i babel-cli browserify -g
>>npm i babel-preset-es2015 --save-dev

3. 在根目录下定义.babelrc文件
   //rc : run control运行时控制
   {
   	"presets":["es2015"]
   }

4. 构建项目
   暴露export {}
   引入import {} from '';

5. 编译
   Babel将ES6转换为ES5,自动创建新文件:

>>babel js/src -d js/lib
>>browserify转换js文件
>>browserify js/src/main.js -o js/dist/bundle.js

6. 验证
   在index.html引入bundle.js文件，浏览器打开即可  

   

## 设计模式

## call、apply、bind

* `.call(新对象，param1,param2,param3...)`修改函数的this，指向一个新对象，并执行一次
* `.apply(新对象，[param1,param2,param3..])`同上，区别在于传参方式不同，这里是数组
* `.bind(新对象，param1,param2,param3...)`只修改this指向不执行

![image-20210709214612337](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210709214612.png)

## new实现

1. 创建一个空对象（堆内存中创建）

2. 设置原型链（运行构造函数）

3. 绑定this（this指向当前空对象）

4. 返回新对象（判断实例化对象返回值）

   ```
   //定义create对象（构造函数）
   function create(){
       //定义空对象
       let obj = {};
       //取出参数列表的第一个参数（构造函数）
       let Con = [].shift.call(arguments);
       //手动指正obj的构造函数为Con（链接原型）
       obj.__proto__ = Con.prototype;
       //调用Con，改变this为obj，传入剩余参数arguments
       let result = Con.apply(obj,arguments);
       //考虑到Con函数中有return的原因，需要对result进行判断
       return result instanceof Object ? result : obj
   }	
   //使用构造函数	
   function create(name,age){
           this.name=name;
           this.age=age;
       }
   var p=new create('lili',18)
   console.log(p.name)    //lili
   console.log(p instanceof create)   //true
   console.log(p.__proto__===create.prototype)   //true
   ```

## 防抖节流

> 应用场景：一般用于高频触发的事件上，目的是优化性能

### 案例

1. 窗口对象上，频繁触发滚动事件，对该事件进行性能优化

2. 主要代码

   ```
   <style>
   	body{
   		height:2000px;
   		width:100%;
   	}
   </style>
   <script>
   	window.onscroll=PrintNum;//满足事件触发条件，会自动执行函数
   	let num=0;
   	function PrintNum(){
   		console.log(num++);
   	}
   </script>
   ```

### 防抖

> 设置一个延迟定时器，让你想要执行的逻辑，等待n秒后执行一次，如果在n秒内又被触发了，则清除计时器（也不会执行逻辑功能了），重新计时

```
function debounce(fun,wait){
	let timeout=null;
	return function(){
		if(timeout){clearTimeout(timeout)};
		timeout=setTimeout(()=>{
			fun();
		},wait)
	}
}
window.onscroll=debounce(PrintNum,1000);//debounce函数只会执行一次，其后执行匿名函数（return后面的）
```

### 节流

> 通过获取触发时间差，让你想要执行的逻辑，在n秒内只会被执行一次

```
function throttle(fun,interval){
	let pre=+new Date();
	return function(){
		let now=+new Date();
		if(now-pre>interval){
			fun();
			pre=now;
		}
	}
}
window.onscroll=throttle(PrintNum,1000);
```

## let var const区别

* var
  1. 定义变量，可以重定义，可以被修改
  2. 在全局定义是全局变量，在函数内部定义是局部变量
  3. 在函数内若没有用var/let定义，会提升为全局变量
* let
  1. 定义变量，不能重定义，可以被修改
  2. 一般用于定义一个块级作用域，一个{}就是一块
* const
  1. 定义常量，不能重定义，不能被修改
  2. 一般用于定义一些接口地址和固定不变的量

![image-20210713085400103](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210713085655.png)

## 暂时性死区

> 在代码块内，使用`let`声明变量之前(包括求值运算)，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

在ES6的新特性中，最容易看到TDZ作用就是在let/const的使用上，let/const与var的主要不同有两个地方:

- let/const是使用区块级作用域；var是使用函数作用域
- 在let/const声明之前就访问对应的变量与常量，会抛出`ReferenceError`错误；但在var声明之前就访问对应的变量，则会得到`undefined`

```
console.log(aVar) // undefined
console.log(aLet) // causes ReferenceError: aLet is not defined
var aVar = 1
let aLet = 2
```

* 只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

  ```
  var tmp = 123;
   
  if (true) {
    tmp = 'abc'; // ReferenceError
    let tmp;
  }
  ```

## eventloop

`Event Loop`即事件循环，是指浏览器或`Node`的一种解决`javaScript`单线程运行时不会阻塞的一种机制，也就是我们经常使用**异步**的原理。

![image-20210713161232286](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210713161247.png)

* 以发送Ajax请求为例，开始，任务先进入 Call Stack
* 同步任务直接在栈中等待被执行，异步任务从 Call Stack 移入到 Event Table 注册
* 当对应的事件触发（或延迟到指定时间），Event Table 会将事件回调函数移入 Event Queue 等待
* 当 Call Stack 中没有任务，就从 Event Queue 中拿出一个任务放入 Call Stack

**而 Event Loop 指的就是这一整个圈圈：**

>  它不停检查 Call Stack 中是否有任务（也叫栈帧）需要执行，如果没有，就检查 Event Queue，从中弹出一个任务，放入 Call Stack 中，如此往复循环。

**案例1：**

> 异步、let和const作用域

```
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
console.log(i);
//console:先打印一个3，一秒后，连续打印3个3出来
```

优化：将以上代码打印为0,1,2，同时具有定时器的效果，每隔一秒打印一次

1. let，每一个for循环生成一个独立的块级作用域，变量之间相互不影响

   ```
   for (let i = 0; i < 3; i++) {
     setTimeout(() => {
       console.log(i);
     }, 1000*i);
   }
   console.log(i);
   //先报错i没有被定义，再每隔一秒打印0，1，2
   ```

2. 闭包，形成一个独立的函数作用域（当延迟函数f()()执行后，延迟时间无作用，除非闭包）

   ```
   for(var i=0;i<3;i++){
   	setTimeout(function(a){
   		return function(){
   			console.log(a);
   		}
   	}(i),i*1000)
   }
   ```

3. 立即执行函数

   ```
   for (var i = 0; i < 3; i++) {
     (function(a){
     	setTimeout(function(){
     		console.log(a);
     	},1000*a)
     })(i);
   }
   ```

   **案例2：**

```
var name;

console.log(name)

setTimeout(() => {
    name = 'jsliang';
    console.log(name);
}, 1000);

console.log(name);

if (name) {
    name = '梁峻荣';
    console.log(name);
}
```

* 当用var声明,先打印jslang,jslang，‘梁峻荣’，一秒后打印jslang

* 当用let申明，先打印两个undefined,一秒后打印jslang

区别：var 里面name='jslang'，是全局有效的值，

​			let里面name的值在全局为undefined,而在不同的代码块里｛｝，取决于作用域当前的name取值

## 事件模型（事件流）

参考文档：[Javascript事件模型](https://blog.csdn.net/starstasts/article/details/62435731?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162616792716780357251132%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162616792716780357251132&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-15-62435731.first_rank_v2_pc_rank_v29_1&utm_term=JS%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B&spm=1018.2226.3001.4187)、[JavaScript 事件模型 事件处理机制](https://blog.csdn.net/chenmoquan/article/details/10162477?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162616792716780357251132%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162616792716780357251132&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-8-10162477.first_rank_v2_pc_rank_v29_1&utm_term=JS%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B&spm=1018.2226.3001.4187)

1. 什么是事件？用户与web页面之间产生的交互效果，比如鼠标点击，键盘按键，事件还可能是web浏览器中发生的事，比如web页面的加载，窗口条的滚动，窗口大小的加载。使用JS可以监听事件的发生以及在事件触发时做出反应。
2. 什么是事件流？当一个HTML元素产生一个事件时，从页面中接收事件的顺序
3. 事件流的分类

   * 冒泡事件

   * 捕获事件

   * IE浏览器仅支持冒泡事件，其他浏览器支持冒泡+捕获

### 冒泡事件

所谓冒泡事件，就是事件从**最精确**的元素触发，向上沿DOM结构冒泡触发至最不精确的元素。（原生句柄和事件监听都可以监听冒泡事件）

![img](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210713210630.png)

![这里写图片描述](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210713210726.png)

### 捕获事件

而捕获事件则相反，事件从**最不精确**的元素触发，向下至最精确的元素。（只有监听器能够监听）

![这里写图片描述](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210713211417.png)

![img](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210713211433.png)

### IE8以下兼容

```
//注册监听事件
function addEvent(element, type, handler){
    if  (element.addEventListener){
    	element.addEventListener(type, handler,  false );
    }  else if  (element.attachEvent){
   		element.attachEvent( " on "   +  type, handler);
    }  else  {
    	element.[ " on "   +  type]  =  handler;
    }
},
// 移除监听事件
function removeEvent(element, type, handler){
    if  (element.removeEventListener){
    	element.removeEventListener(type, handler,  false );
    }  else   if  (element.detachEvent){
    	element.detachEvent( " on "   +  type, handler);
    }  else  {
    	element.[ " on "   +  type]  =   null ;
    }
    }             
}; 
```

### 阻止冒泡事件

* 停止冒泡事件（event.stopPropagation()）

  冒泡型事件传递中，在某元素处处理停止事件传递后，位于上层的document的事件监听器就不再收到通知，不再被处理。

*  阻止事件的默认行为(event.preventDefault)

  1. 停止事件的默认行为是指，通常浏览器在事件传递并处理完后会执行与该事件关联的默认动作（如果存在这样的动作）。

  2. 例如，如果表单中input type 属性是 “submit”，点击后在事件传播完浏览器就自动提交表单。

  3. 又例如，input 元素的 keydown 事件发生并处理后，浏览器默认会将用户键入的字符自动追加到 input 元素的值中。

**停止冒泡的兼容写法**

```
function  someHandle(event) {
    event  =  event  ||  window.event;
    if (event.stopPropagation){
    	event.stopPropagation();//兼容标准DOM
    } else  {
    	event.cancelBubble  =   true ;//兼容IE
    }
}
```

**阻止事件默认行为兼容**

```
function  someHandle(event) {
    event  =  event  ||  window.event;
    if (event.preventDefault){
    	event.preventDefault();//兼容标准DOM
    else {
    	event.returnValue  =   false ;//兼容IE
    }
}
```

## 事件对象（event）

1. 为了更好的处理事件，我们可以根据所发生的事件对象，以及其特定属性来采取不同的操作，例如：鼠标位置、按键的键值/键名，事件源。

2. 不同浏览器下的事件对象获取兼容性不同

   * IE 使用一个叫做 event 的全局事件对象来处理对象（它可以在**全局变量window.event**中找到,不能用let定义否则undefined）
   * 其它所有浏览器采用的 W3C 推荐的方式，则使用独立的包含事件对象的参数传递（使用时传入的第一个参数）

3. 获取事件对象

   **ie浏览器**

   ```
   el.事件类型=function(){
   	var e=window.event
   }
   ```

   **DOM标准**

   ```
   el.事件类型=function(event){
   	var e=event
   }
   ```

   **兼容版本**

   ```
   el.事件类型=function(event){
   	var e=event || window.event
   }
   ```

4. 获取事件源

   * ie:  e.srcElement;

   * 标准： e.target;

   * 兼容

     ```
     el.事件类型=function(event){
     	var e=event || window.event
     	let tag=e.target || e.srcElement
     }
     ```

5. 获取鼠标坐标

   水平方向：e.clientX

   垂直方向：e.clientY

## 事件委托

1. 事件委托利用事件冒泡机制，将子元素的事件写一个父元素,让父元素代替处理,内部使用e.target,e.target获取触发这个事件的子元素。

2. 比较典型的例子是，一个 ul 元素 中的所有 li元素 都需要绑定统一类型的事件，那么只需要给这个 ul 绑定事件就可以了～

3. 适用场景，多个需要处理的事件。

   ![这里写图片描述](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210713221225.png)

   ![这里写图片描述](https://gitee.com/houyanxi/personal-drawing-bed/raw/master/personal-drawing-bed/20210713221251.png)

## 事件句柄&监听

事件的注册主要有三种

### 事件句柄

1. 标签注册

   ```
   <元素名 onclick="函数名（）">文本内容</元素名>
   function 函数名（）{}
   ```

   注意：这种方式违背了将实现动态行为的代码与显示文档静态内容的代码相分离的原则，不推荐。

2. 声明注册

   ```
   var  link = document.getElementById( " mylink " );
   	link.onclick = function (){
   	alert( " I was clicked ! " );
   }; 
   ```

   注意：将同类型事件多次注册给同一事件源，后面的事件会覆盖前面的事件

### 事件监听

3. **事件监听注册**

除了的简单事件句柄之外，现在大多数浏览器都内置了一些更高级的事件处理方式，即，事件监听器，这种处理方式就不受一个元素只能绑定一个同类事件句柄的限制。

```
el.addEventListener('取代on的事件',函数名,useCapture)
```

参数1：监听事件的类型，"click"、"copy"、“load”

参数2：监听事件执行的功能函数，可以是函数名，也可以是匿名函数

参数3：是否使用事件流，默认为false冒泡，true为捕获

**移除掉监听事件**

```
el.removeEventListener('click',function(){},useCapture)
```

**ie版本的事件监听注册和移除**

```
//注册
element.attachEvent( " onevent " ,eventListener);
//移除
element.detachEvent( " onevent " ,eventListener);
```

参数1：事件类型，要加on-,比如‘onclick’

参数2：监听事件执行的功能函数，可以是函数名，也可以是匿名函数

注意：利用attachEvent注册的处理函数调用时this指向不再是先前注册事件的元素，这时的this为window对象。

## JS浅拷贝和深拷贝

1. 深拷贝和浅拷贝值针对Object和Array这样的复杂类型，复制的是内存地址给另一个对象

2. a和b指向了同一块内存，所以修改其中任意一个值，另外一个值也会随之变化，这是浅拷贝。浅拷贝遍历一层，适用于对象下面是基础数据，若是引用数据，仍然相关联。

3. a和b指向同一块内存，但是修改其中任意一个值，另外一个调用的变量，不会受到影响，这是深拷贝。深拷贝可遍历多层，并且拷贝出来数据之间无关联。

### 浅拷贝

```
var people ={
    "username":"mary",
    "age":"20",
    "info":{"tel":"1234566","celltelphone":788666},
    "address":[
        {"city":"beijing","code":"1000022"},
        {"city":"shanghai","code":"2210444"}
    ]
};
//浅拷贝---01_遍历赋值
var people1={};
for(var i in people){
	people1[i]=people[i];
}

console.log(people===people1);//false
console.log(people.username='lili');
console.log(people1.username);//mary
console.log(people.info===people1.info);//true
console.log(people.info.tel='00000');
console.log(people1.info.tel);//00000
```

```
//浅拷贝---02_Object对象的assign();
var people1=Object.assign({},people);

//Objcet.assign(target,...source);
ES6的方法，用于合并多个JS对象，将源对象合并到目标对象上，并返回一个新对象
```

### 深拷贝

```
//深拷贝--01字符串转换，注意函数不能被正确处理
var people1=JSON.parse(JSON.stringify(pepele));
```

```
//深拷贝--02递归
function deepcopy(obj){
	var p=obj instanceof Array?[]:{};
	for(var i in obj){
		if(type obj[i]=='object'{
			p[i]=deepcopy(obj[i]);//递归入口
		}else{
			p[i]=obj[i]//递归出口
		}
	}
	return p
}
var people1=deepcopy(people);
```

