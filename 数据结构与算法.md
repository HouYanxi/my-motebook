# 数据结构与算法绪论

> 什么是数据结构 ？ **程序设计=数据结构+算法** 
>
> 数据结构就是关系，数据元素之间存在的一种或多种特定关系的集合

## 数据结构分类

1. 逻辑结构：数据元素之间的相互关系， **讨论的重点**
2. 物理结构：数据的逻辑结构在计算机中的存储形式 ，*这里的存储是争对内存而言的，类似硬盘，软盘，光盘等外部存储的数据组织结构用文件结构来描述*

### 四大逻辑结构

1. 集合结构：同属一个集合，元素之间没有关系

   ![image-20200326112500122](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200326112500122.png)

2. 线性结构：元素是一对一的关系

   ![image-20200326112830488](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200326112830488.png)

3. 树形结构：元素是一对多的关系

   ![image-20200326113046150](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200326113046150.png)

4. 图形结构：元素多对多的关系

   ![image-20200326113236979](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200326113236979.png)

### 两大物理结构

1. 顺序存储结构：将数据存放在**地址连续**的存储单元里，数据间的逻辑关系和物理关系是一致的，***eg：数组***

   ![image-20200326114341614](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200326114341614.png)

2. 链式存储结构：

   * 争对时常要变化的结构，顺序存储不能满足。

   * 将数据存放在**任意**的存储单元里，这组存储单元可以是连续的，也可以是不连续的。

   * 链式存储结构的物理关系并不能反映其逻辑关系，引入**指针**存放数据元素的地址，通过指针寻找相关联元素的位置。

   * 指针就是一条链，指针指向下一个元素的地址

     ![image-20200326120133915](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200326120133915.png)

## 算法概述

> 解决特定问题求解步骤的描述，在计算机里表现为指令的有限集合，并且每条指令表现为一个或多个操作***算法不是唯一的***

### 算法的特征

1. 输入：算法具有零个或多个输入（通俗来讲就是函数的参数）

```
void print(){
 printf("I Love U\n");
}
```

2.输出：至少有一个输出或多个输出（两种输出形式：**打印输出**，**返回一个或多个值**）

3.有穷性：算法在执行有限步骤后，自动结束而不会出现无限循环（每个步骤要在可接受时间内完成）

4.确定性：算法每一步都需要有确定的含义

5.可行性：每一步都必须是可行的（当前环境下，有限次数完成）

### 算法设计要求

1.正确性

* 算法程序没有语法错误

* 对于合法输入能够产生满足要求的输出

* 对于非法输入产生满足规格的说明（对用户进行说明提示）

* 对于故意刁难的测试输入都有满足要求的输出结果

2.可读性：便于自己和他人阅读，日后修改维护

3.健壮性：对输入数据不合法，刻意刁难能做出相应处理。

4.时间效率高和存储量低

### 算法效率

> 一个程序运行的好坏，除开计算机硬件、软件有关因素（机器执行指令速度、编译代码指令），一个程序运行时间依赖于算法的好坏和问题的输入规模（输入量）

**提高算法效率=>减少时间复杂度+空间复杂度**

#### 算法效率概述


1. 求和案例：

```
//算法一：共执行2n+2次 O(n)
int i,sum=0,n=100;//执行1次
for(i=1;i<=n;i++){//执行n+1次
	sum=sum+i;    //执行n次
}

//算法二:共执行2次 O(1)
int sum=0;n=100;//执行1次
sum=(1+n)*n/2;  //执行1次

//算法三：共执行3n^2 O(n2)
int i,j,x=0,sum=0,n=100;
for(i=1,i<=n,i++){//执行n+1
	for(j=1;j<=n;j++){//执行n+1*n+1
		x++;
		sum=sum+x;
	}
}
```

2. 函数的渐近增长（对比GHI三个算法）

![image-20200327113116897](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200327113116897.png)

微观上：

![image-20200327113433282](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200327113433282.png)

宏观上：

![**](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200327113532786.png)

**说明**：横轴：输入量n，竖轴：算法运行成功执行次数N

**结局**：算法效率：H>G>I

**结论**：函数的常数和次要项可以忽略，应该关注主项（最高项）的阶数，少量的数据是不能做出准确判断的

*****

#### 时间复杂度

1. 定义：语句总的执行次数T(n)是关于问题规模n的函数，算法的时间度量度，记作：T(n)=O(f(n)),CPU执行次数称为单位时间

2. 规律：一般情况下随着问题规模n的增大，T(n)增长最慢的算法为最优的算法

3. 求和算法时间复杂度

   ![image-20200327201955467](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200327201955467.png)

4. 时间复杂度O推导攻略：
   * 常数1取代运行时间中所有加法常数
   * 修改后的运行次数函数中，只保留最高阶项
   * 最高阶项存在且不是1，则去除与这个项相乘的常数
   * 最后得到大O阶

5. 平方阶案例

   ```
   int i,j,n=100;
   for(i=0;i<n;i++){    // 0 1   2    执行次数
   	for(j=i;j<n;j++){// n n-1 n-2
   		printf("I Love U");
   	}
   }
   0+1+2+...n-2+n-1+n=1+...n=(1+n)*n/2=O(n^2)
   ```

​      对数阶案例

```
int i=1,n=100;
while(i<n){ 
	i=i*2;  
}
//i每次增大2倍，假设这样执行x后，i大于等于n退出循环
// 2^x=n
//x=log(2)n 2为底数 => O(logn)
```

6.常用时间复杂度所耗费的时间从小到大： O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)

*****

#### 空间复杂度

> 编写代码时，完全可以用空间置换时间

1. 案例

   判断某年是不是闰年？

   ```
   //一：牺牲时间
     每给一个年份，就通过某个功能函数去计算得到的年份是否是闰年
   //二：牺牲空间
     事先建立一个有2050个元素的数组，把所有年份按下标的数字对应，若是闰年则数组元素为1，不是则为0，判断某一年是否为闰年就变成查找数组某一个元素的值。
   ```

2. 定义：空间复杂度指的是空间运行需求 S(n)=O(f(n))

## 线性表（List）

1. 定义：由零个或多个数据元素组成的有限序列，线性表元素个数为n(n>=0),n为线性表的长度，当n为0时，称为空表。

2. 定义解析强调
   * **序列**，元素有先来后到的顺序
   * **多个元素**，第一个无前驱，而最后一个无后继，其它元素都**有且只有一个**前驱和后继。
   * **有限**，所处理的元素个数是有限的

3. 以数学语言定义线性表

   ![image-20200327212750667](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200327212750667.png)

​       表中ai-1领先于ai,则称ai-1为ai的前驱，ai+1为ai的后继

4. 抽象数据类型（Abstract Data Type）

   抽象是对具体事物的一个概括，包括事务具有的普遍性本质，隐藏了繁杂的细节类似于高级语言中的类，类包含具体的属性和方法，对已有的数据类型进行抽象，就有了抽象数据类型，**抽象数据类型可以是在设计软件程序时自己定义的数据类型**。

```
//抽象数据类型标准格式,伪代码
ADT 抽象数据类型名
Data
	数据元素之间逻辑关系的定义
Operation
	操作
endADT
```

### 线性表的抽象数据类型

1. 伪代码定义

```
ADT 线性表（List）
Data
	线性表的数据对象集合为{a1,a2,..an},每个元素类型为DataType.其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间俺的关系是一对一的关系。
Operation
	InitList(*L):初始化操作，建立一个空的线性表L.
	ListEmpty(L):判断线性表是否为空表，若线性表为空，返回true,否则返回false.
	ClearList(*L):将线性表清空【内存中的数据只能被覆盖，以零代替，内存位置仍然被占】
	GetElem(L,i,*e):将线性表L中的第i个位置元素值返回给e
	LocateElem(L,e):在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败【与数组不同，线性表序号从1开始】
	ListInsert(*L,i,e):在线性表L中第i个位置插入新元素e
	ListDelete(*L,i,*e);删除线性表L中第i个位置元素，并用e返回其值
	ListLength(L):返回线性表L的元素个数
endADT
```

2. 以上操纵是基本操作，更复杂的操作是这些操作的组合，实现两个线性表的并集操作A=AUB【将存在与B中不存在于A中的元素全部插入到A中】
   * LisLength(L)
   * GetElem(L,i,*e)
   * LocateElem(L,e)
   * ListInsert(*L ,i,e)
   * 以下是伪代码

![image-20200401115528886](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200401115528886.png)

### 线性表两种存储结构

#### 线性表的顺序存储结构

1. 定义：用一段**地址连续**的存储单元依次存储线性表的数据元素

2. 线性表顺序存储的结构代码

   ```
   #define MAXSIZE 20
   typedef int ElemType;
   typedef struct{
   	ElemType data[MAXSIZE];//数组data
   	int length;//线性表当前长度
   }SqList;
   ```

3.顺序存储结构封装的三个属性

* **存储空间起始位置**，数组data[],他的存储位置就是线性表存储空间的存储位置
* 线性表的**最大存储容量**，数组的长度MAXSIZE   (数组长度是存放线性表的存储空间总长度，一般初始化后不变)
* 线性表的**当前长度**：length（线性表中元素的个数，是会变化的，length<=MAXSIZE+1）




4. 线性表的地址计算

> 数组从0开始计算【至第ai个元素下标为i-1，数组长度为i】，线性表从1 开始计算，线性表中第i个值相当于数组data[i-1]

假设ElemType占用的是c个存储单i元（字节，例如int,是4字节），那么线性表中第i+1个数据元素和第i个数据元素的存储位置的关系是,LOC表示获取存储位置的函数：LOC（ai+1）=LOC(ai) + c

对于第i个数据元素ai的存储位置可以有a1推算得出

LOC(ai)=LOC(a1)+(i-1)*c

![image-20200401181555364](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200401181555364.png)

5. GetElem(L,i,*e)，获取线性表L第i个位置元素值返回给e,只需把数组第i-1下标的值返回即可，伪代码

   ![image-20200401182009615](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200401182009615.png)

6.线性表插入操作，ListInsert(*L,i,e):在线性表L中第i个位置插入新元素e

插入算法思路

* 插入位置不合理，抛出异常；
* 线性表插入位置i，i大于等于1，小于等于线性表长度length+1，插入到线性表最后一个元素后面，否则抛出异常或动态增加数组容量；
* 从最后一个元素开始向前遍历到第i个位置，分别将他们都向后移动一个位置；
* 数组排序，将要插入的元素插入位置i-1处；
* 线性表长度+1；

![image-20200401183716568](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200401183716568.png)

7. 删除操作，ListDelete(*L,i,*e);删除线性表L中第i个位置元素，并用e返回其值

删除算法思路

* 判断线性表是否为空
* 删除元素i的位置是否符合线性表长度【1，length】
* 将要删除的元素返回给e
* 元素删除后，数组排序，从第i个位置开始元素依次往前移动一位，这里不包含删除的元素是最后一个元素的情况，不用移位
* 线性表长度-1

![image-20200402113912242](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200402113912242.png)

##### 结论

1. 时间复杂度
   * 线性表顺序存储结构，存读数据是，时间复杂度都为O（1）
   * 插入和删除操作时，除非其位置在最后一个元素处，不用移动位置，时间复杂度为O(1)，通常都是O(n)

2. 优点
   * 无需为表中元素之间逻辑关系而增加额外的存储空间
   * 可以快速地存取表中任意位置的元素

3. 缺点
   * 插入和删除操作需要移动大量的元素
   * 线性表长度变化较大是，难以确定存储空间容量
   * 容易造成存储空间“碎片”（申请空间都是一大块的，初始化后不变，小块空间都浪费了）

******

#### 线性表链式存储结构

> 顺序存储结构的元素都是相邻的，因此进行插入和删除操作时需要移动大量元素，耗费时间

定义：用一组**任意的**存储单元存储线性表数据元素，这组存储单元可以存在内存中未被占用的任意位置。链式存储结构中，每个元素除了要存储数据元素信息外，还有存储他的后继元素的存储地址（**指针**）

##### 单链表

1. 单链表（每个节点只包含一个指针域，第一个节点存储地址叫做头指针，最后一个节点指针为空null）

![image-20200402204814645](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200402204814645.png)

2. 头指针和头节点

* 无论链表是否为空，头指针均不为空，头指针具有标识作用，常用头指针冠以链表的名字（指针变量的名字）
* 头节点不一定是链表必须元素

![image-20200402210310510](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200402210310510.png)

3. 单链表定义伪代码

```
typedef struct Node{
	ElemType data;      //数据域
	struct *Node Next;  //指针域,指向节点类型的指针
}Node;
typedef struct *Node LinkList;
```

   **eg**:假设P是指向线性表第i个元素的指针，则该节点ai的数据域我们可以用

P->data表示，指针域可以用P->Next表示，P->Next指向第i+1个元素。

4. 读取单链表第i个元素思路

* 声明一个节点P,指向链表的第一个节点，初始化j从1开始
* 当  j<i  时，遍历链表，让P的指针向后移动，不断指向下一个节点，j累加
* 若到链表末尾P为空，则说明第i个元素不存在
* 否则查找成功  j==i  ，返回节点P的数据

![image-20200402213218398](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200402213218398.png)

5. 单链表的插入

将节点s插入到节点p之后,也就是元素ai（元素ai就是p节点）和ai+1之间,只需改变两步

* s->next=p->next    //由s节点指针代替p节点指向下一个ai+1元素
* p->next=s               // p节点指向s节点
* 注意，以上两步顺序不能改变，第二步s节点会覆盖p节点的指针域

![image-20200402214928735](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200402214928735.png)

单链表第i个位置插入元素思路

* 声明一个节点P,指向链表的第一个节点，初始化j从1开始
* 当  j<i  时，遍历链表，让P的指针向后移动，不断指向下一个节点，j累加
* 若到链表末尾P为空，则说明第i个元素不存在
* 否则查找成功  j==i  ，生成一个空节点S
* 对空节点赋值   s->data=e
* 执行两步插入语句
* 返回成功

![image-20200402220426736](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200402220426736.png)

6. 单链表节点的删除

   删除节点p后面的节点q(节点p为a1,节点q为a2),也就是让a1指向a3

   * p->next=p->next->next   / q=p->next  ; p->next=q->next

删除操作算法

* 声明一个节点P,指向链表的第一个节点，初始化j从1开始
* 当  j<i  时，遍历链表，让P的指针向后移动，不断指向下一个节点，j累加
* 若到链表末尾P为空，则说明第i个元素不存在
* 否则查找成功  j==i  ，将欲删除的节点**p->next**赋值给q
* 执行删除语句 p->next=q->next
* 将q节点中的数据赋值给e,返回

![image-20200402223048773](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200402223048773.png)

##### 单链表优势

对于顺序存储结构，单链表对于插入和删除数据频繁的操作优势更明显

**eg:**     从第i个位置开始，连续插入10个元素

* 顺序存储：每次插入一个元素都需要移动n-i个元素位置，每次都是O(n)
* 单链表：只需在第一次找到第i个位置的指针，此时为O(n),接下来只是简单的赋值，时间复杂度都是O(1)

##### 单链表整表创建

> 单链表不像顺序存储结构数据那么集中，他的数据可以是分散在内存各个角落的，他所占用空间大小和位置不需要预先分配划定，可以根据系统的情况和实际需求及时生成

1. 单链表整表创建算法思路

* 声明一个节点p和计数器变量i;
* 初始化一个空链表L;
* 让L的头节点的指针指向NULL,即建立一个带头节点的空单链表
* 循环实现后继节点的赋值和插入

2. 头插法，在链表创建的基础上，始终让新节点p插在第一的位置

   * 先让新节点的next指向头节点      p->next=(*L)->next

   * 再让表头的next指向新节点      （*L）->next=p

     ![image-20200403104436605](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200403104436605.png)

​             头插法伪代码

​             ![image-20200403110400017](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200403110400017.png)

3. 尾插法（始终让新节点p插在最后的位置）
   * 让指向链表尾部的节点r指向新插入的节点p //r->next=p
   * 新节点p插入进链表尾部                                 //r=p

![image-20200403132453291](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200403132453291.png)

尾插法伪代码（p新节点，r始终指向尾部的节点）

![image-20200403133024020](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200403133024020.png)

4.单链表的整表删除

> 其实就是在内存中将他释放掉，以便留出空间给其他的程序或软件使用

删除算法思路

* 声明节点p和q
* 将第一个节点赋值给p,下一个节点赋值给q;
* 循环执行释放p和将q赋值给p的操作【p节点释放后，其数据域和指针域都会被释放，因此要声明一个q节点存放下一个节点】

![image-20200404163607246](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200404163607246.png)

#### 静态链表

> 用数组代替指针来描述单链表，叫做静态链表，也叫做游标实现法。

![image-20200404181733671](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200404181733671.png)

**说明**：

* 下标为0的位置和下标MAXSIZE-1的位置无数据，

* 且对应的游标分别是数据段最后一个元素下标加1【其游标用于存放备用链表的第一个节点下标】和数据段第一个元素下标【相当于单链表的头节点】

* 通常把未使用的数组元素称为备用链表

* 所有数据段的元素游标都是指向其下一个元素的下标，数据段最后一个元素游标为0

  ![image-20200404212029847](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200404212029847.png)

1.静态链表存储结构伪代码

```
#define MAXSIZE 1000
typedef struct{
	ElemTypr data;  //数据
	int cur;        //游标（Cursor）
}Component,StaticLinkList[MAXSIZE];
```

2.静态链表初始化（相当于初始化数组）

```
static InitList(StaticLinkLisit space){
	int i;
	for(i=0;i<MAXSIZE-1;i++){
		space[i].cur=i+1;
	}
	space[MAXSIZE-1].cur=0;
	return OK;
}
```

3.静态链表的插入元素

![image-20200404181733671](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200404181733671.png)

第一步：获得空闲分量【下标为0的第一个元素】的游标

```
int Malloc_SSL(StaticLinkList space){
	int i=space[0].cur;//下标为0的游标，获得备用链表第一个元素的下标
	if(space[0].cur){
		space[0].cur=space[i].cur;//插入元素的游标即新的备用链表第一个元素下标
	}
	return i;    //i=5
}
```

第二步：执行插入操作

![image-20200404204335176](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200404204335176.png)

![image-20200404181807818](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200404181807818.png)

**思考**：3B和4B的游标变化，元素如何插入？

4. 静态链表的删除元素

   第一步：删除元素，修改数据对应游标

   ![image-20200404211147375](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200404211147375.png)

   第二步：回收被删除元素空间到备用链表里

   ![image-20200404211552812](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200404211552812.png)

   ![image-20200404210824039](C:\Users\AS\AppData\Roaming\Typora\typora-user-images\image-20200404210824039.png)

